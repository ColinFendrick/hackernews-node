## Server

graphql-yoga: Fully-featured GraphQL server with focus on easy setup, performance & great developer experience. Built on top of Express, apollo-server, graphql-js and more.
Prisma: GraphQL abstraction layer that turns your database into a GraphQL API which provides powerful, realtime CRUD operations for your data model.
Node.js: Runtime environment for building servers with JavaScript. GraphQL itself is programming language agnostic, so check out the other tutorials in this section if you prefer to use another language.
GraphQL Playground: Extremely useful tool for quickly testing GraphQL APIs. There’s no need to build a whole frontend app just to test use cases, but it can also be a pain to build and send GraphQL requests manually using Postman or other similar tools. Among other things, GraphQL Playgrounds…

… auto-generate a comprehensive, multi-column documentation for all your available queries and mutations.
… provide a text editor where you can write queries, mutations & subscriptions, with syntax highlighting and autocompletion.
… let you specify HTTP headers for your queries and mutations.

### API requirements
Here you’re going to build the backend for a Hackernews clone, so let’s think about the requirements your API should provide:

- Retrieve a list (feed) of link elements
- Allow users to signup up with their name, email and password
- Users who signed up should be able to login again with their email and password
- Allow authenticated users to post new link elements
- Allow authenticated users to upvote an existing link element
- Send realtime updates to subscribed clients when a new link element is created
- Send realtime updates to subscribed clients when an existing link element is upvoted

`src` contains the javascript code, application schema, and prisma schema
`databse` stores related Prisma database services
- `prisma.yml` is the root config for the prisma database service. Here is a name for the service as well as deployment information and a data model generating the Prisma CRUD API
- `datamodel.graphql` provides the foundation for the database in `prisma.graphql` which has create, read, update, delete instances of the data type

### App schema from prisma schema
- `src/schema.graphql` **Application schema** is the graphql api that will be exposed to client
- `src/generated/prisma.graphql` **Prisma schema** is the prisma api with crud functionality. This is autogenerated based on data model and --should never be manually altered--
- `database/datamodel.graphql` Data model contains the type definitions for the entities in our domain. Prisma will generate queries and mutations allowing read/write functionality on database records for that type

### Instantiating a `GraphQL Server`
```
const server = new GraphQLServer({
  typeDefs: './src/schema.graphql',
  resolvers,
  context: req => ({
    ...req,
    db: new Prisma({
      typeDefs: 'src/generated/database.graphql',
      endpoint: 'http://localhost:60000/hackernews-node/dev',
      secret: 'mysecret123',
    }),
  }),
})
```

- `typeDefs` are type definitions imported from schema
- `resolvers` is a JSON that mirrors the query/mutation/subscription types and their fields from app schema. Each field in that app schema is represented by a function with the same name in that object
- `context` is an object that gets passed through the resolver chain and every resolver can read or write to 

`Context` Notice that the context object has the db field which contains an instance of Prisma from the prisma-binding package. This instance will allow your resolvers to simply delegate the execution of an incoming request to an appropriate resolver from the Prisma API.

When instantiating Prisma, you need to provide information about your Prisma database service:

typeDefs: The type definition from your Prisma schema
endpoint: The HTTP endpoint of your Prisma database service
secret: The secret which allows to access the Prisma database service (this is defined in prisma.yml)
Because you provide this information, the Prisma instance will get full access to your database service and can be used to resolve incoming request later on.

Every field on your Query and Mutation types will be backed by a resolver function which is responsible for fetching the corresponding data. The first resolver you’ll implement is the one for feed.
In terms of code organization, the resolvers for your queries, mutations and subscriptions will be written in dedicated files called Query.js and Mutation.js and Subscription.js. They’ll then be referenced in index.js to instantiate your GraphQLServer.

The resolver receives four input arguments:

parent: Contains an initial value for the resolver chain (you don’t have to understand in detail what it’s used for in this tutorial; if you’re curios though, you can check this article).
args: This object contains the input arguments for the query. These are defined in the application schema. In your case that’s filter, first and skip for filtering and pagination.
context: The context is an object that can hold custom data that’s passed through the resolver chain, i.e. every resolver can read from and write to it.
info: Contains the abstract syntax tree (AST) of the query and information about where the execution in the resolver chain currently is.

The filter argument is used to build a filter object (called where) to retrieve link elements where the description or the url contains that filter string.
Finally, the resolver simply delegates the execution of the incoming query to the links resolver from the Prisma API and returns the result of that execution.