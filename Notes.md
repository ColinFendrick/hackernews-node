## Server

graphql-yoga: Fully-featured GraphQL server with focus on easy setup, performance & great developer experience. Built on top of Express, apollo-server, graphql-js and more.
Prisma: GraphQL abstraction layer that turns your database into a GraphQL API which provides powerful, realtime CRUD operations for your data model.
Node.js: Runtime environment for building servers with JavaScript. GraphQL itself is programming language agnostic, so check out the other tutorials in this section if you prefer to use another language.
GraphQL Playground: Extremely useful tool for quickly testing GraphQL APIs. There’s no need to build a whole frontend app just to test use cases, but it can also be a pain to build and send GraphQL requests manually using Postman or other similar tools. Among other things, GraphQL Playgrounds…

… auto-generate a comprehensive, multi-column documentation for all your available queries and mutations.
… provide a text editor where you can write queries, mutations & subscriptions, with syntax highlighting and autocompletion.
… let you specify HTTP headers for your queries and mutations.

### API requirements
Here you’re going to build the backend for a Hackernews clone, so let’s think about the requirements your API should provide:

- Retrieve a list (feed) of link elements
- Allow users to signup up with their name, email and password
- Users who signed up should be able to login again with their email and password
- Allow authenticated users to post new link elements
- Allow authenticated users to upvote an existing link element
- Send realtime updates to subscribed clients when a new link element is created
- Send realtime updates to subscribed clients when an existing link element is upvoted

`src` contains the javascript code, application schema, and prisma schema
`databse` stores related Prisma database services
- `prisma.yml` is the root config for the prisma database service. Here is a name for the service as well as deployment information and a data model generating the Prisma CRUD API
- `datamodel.graphql` provides the foundation for the database in `prisma.graphql` which has create, read, update, delete instances of the data type

### App schema from prisma schema
- `src/schema.graphql` **Application schema** is the graphql api that will be exposed to client
- `src/generated/prisma.graphql` **Prisma schema** is the prisma api with crud functionality. This is autogenerated based on data model and --should never be manually altered--
- `database/datamodel.graphql` Data model contains the type definitions for the entities in our domain. Prisma will generate queries and mutations allowing read/write functionality on database records for that type

### Instantiating a `GraphQL Server`
```
const server = new GraphQLServer({
  typeDefs: './src/schema.graphql',
  resolvers,
  context: req => ({
    ...req,
    db: new Prisma({
      typeDefs: 'src/generated/database.graphql',
      endpoint: 'http://localhost:60000/hackernews-node/dev',
      secret: 'mysecret123',
    }),
  }),
})
```

- `typeDefs` are type definitions imported from schema
- `resolvers` is a JSON that mirrors the query/mutation/subscription types and their fields from app schema. Each field in that app schema is represented by a function with the same name in that object
- `context` is an object that gets passed through the resolver chain and every resolver can read or write to 

`Context` Notice that the context object has the db field which contains an instance of Prisma from the prisma-binding package. This instance will allow your resolvers to simply delegate the execution of an incoming request to an appropriate resolver from the Prisma API.

When instantiating Prisma, you need to provide information about your Prisma database service:

typeDefs: The type definition from your Prisma schema
endpoint: The HTTP endpoint of your Prisma database service
secret: The secret which allows to access the Prisma database service (this is defined in prisma.yml)
Because you provide this information, the Prisma instance will get full access to your database service and can be used to resolve incoming request later on.

Every field on your Query and Mutation types will be backed by a resolver function which is responsible for fetching the corresponding data. The first resolver you’ll implement is the one for feed.
In terms of code organization, the resolvers for your queries, mutations and subscriptions will be written in dedicated files called Query.js and Mutation.js and Subscription.js. They’ll then be referenced in index.js to instantiate your GraphQLServer.

The resolver receives four input arguments:

parent: Contains an initial value for the resolver chain (you don’t have to understand in detail what it’s used for in this tutorial; if you’re curios though, you can check this article).
args: This object contains the input arguments for the query. These are defined in the application schema. In your case that’s filter, first and skip for filtering and pagination.
context: The context is an object that can hold custom data that’s passed through the resolver chain, i.e. every resolver can read from and write to it.
info: Contains the abstract syntax tree (AST) of the query and information about where the execution in the resolver chain currently is.

The filter argument is used to build a filter object (called where) to retrieve link elements where the description or the url contains that filter string.
Finally, the resolver simply delegates the execution of the incoming query to the links resolver from the Prisma API and returns the result of that execution.

When adding a mutation to your API, you need to add a corresponding field to the Mutation type of your GraphQL schema and then implement the resolver for that field. Just like with queries!

When accessing a Prisma database service (over HTTP), you need to authenticate by attaching an authentication token to the Authorization field of your HTTP header. Otherwise, the request is going to fail.

But where do you get this authentication token from? Well, you can actually generate it yourself, it’s a JSON web token (JWT) that needs to be signed with the Prisma service secret which is specified as the secret property in your prisma.yml.

In most cases however (when using prisma-binding or the Prisma CLI) the JWT token is actually generated for you so you don’t have to worry about that at all and all you need to do is initally provide the secret. This is also why the Prisma instance in index.js receives the secret as a constructor argument, so it can generate JWTs under the hood. Another example is the prisma playground command from the CLI. This will generate a token and set it as the Authorization header when the Playground is opened, so you can start sending queries and mutations right away.
This however only protects your database from unauthorized access, but it doesn’t help in offering authentication functionality to the users of your application. This you need to implement yourself!

For simplicity, you’ll define your application secret as a global constant in this tutorial. In real-world applications, you should always make sure your secrets are properly protected, e.g. by setting them as environment variables rather than hardcoding them in your source files!

Signup
To signup (i.e. create a new User node), the following steps need to be performed:

The server receives a signup mutation with the email and password (and name) of a new user
The server creates a new user in the database and stores the name and email as well as a hashed version of the password
The server generates an authentication token (JWT) by signing the token’s payload (which is the user’s id) with the application secret
The server returns the authentication token and user info to the client who made the request

The server receives a login mutation with the email and password of an existing user
The server compares the hashed version of the password that’s stored with the password that was received in the login mutation
If the passwords match, the server generates an authentication token (JWT) by signing the token’s payload (which is user’s id) with the application secret
The server returns the authentication token and user info to the client who made the request


the steps for creating adding a new feature to your GraphQL API:

1. Adjust data model (if necessary)
2. Deploy Prisma database service to apply changes to data model (if necessary)
3. Add new root field (on the Query, Mutation or Subscription field) to application schema
4. Implement the resolver for the new root field

### Subscriptions
Subscriptions are a GraphQL feature that allows the server to send data to the clients when a specific event happens. Subscriptions are usually implemented with WebSockets, where the server holds a steady connection to the client. This means you’re not using the Request-Response-Cycle that we used for all previous interactions with the API any more. Instead, the client initially opens up a steady connection to the server by specifying which event it is interested in. Every time this particular event happens, the server uses the connection to push the data that’s related to the event to the client.

To implement subscriptions for your GraphQL API, you follow the same process of adding queries and mutations. First add them to your application schema, then implement the corresponding resolvers.

The main process you went through for each feature you implemented consisted of these steps:

- Adjust the Prisma data model to account for the data the new feature requires (e.g. adding a User type for implementing authentication).
- Deploy the Prisma database service to apply the changes from the previous step, this will update your auto-generated Prisma schema which contains all the CRUD operations for the types in your data model.
- Add a new root field to the application schema that represents the feature (e.g. post(url: String!, description: String!): Link! for posting new links).
- Implement the resolver for the root field by delegating the execution to the Prisma database service using the prisma-binding package.
